#import "./pokeGame.jsligo" "PokeGame"

import Test = Test.Next;
import Tezos = Tezos.Next;

export const setUpAccounts = ((): [address, address] => {
  // Set up test account
  Test.State.reset(2 as nat, list([]) as list<tez>);
  const account1: address = Test.Account.address(0);
  const account2: address = Test.Account.address(1);
  Test.IO.log(
    "Account 1 has address "
    + Test.String.show(account1)
    + " and balance "
    + Test.String.show(Test.Address.get_balance(account1))
  );
  return [account1, account2];
});

const accounts = setUpAccounts();

const defaultLambda: PokeGame.feedbackFunction = (
  (targetAddress: address): string => {
    return match(Tezos.View.call("feedback", unit, targetAddress) as option<string>) {
      when(Some(feedback)): feedback
      when(None()): failwith("Cannot find view feedback on given contract address")
    };
  }
);

const updatedLambda: PokeGame.feedbackFunction = (
  (targetAddress: address): string => {
    return match(Tezos.View.call("feedback", unit, targetAddress) as option<string>) {
      when(Some(feedback)): feedback + " updated"
      when(None()): failwith("Cannot find view feedback on given contract address")
    };
  }
);

// Default storage
export const initial_storage: PokeGame.storage = {
  messages: Map.empty,
  feedback: "Hello",
  ticketOwnership: Map.empty,
  feedbackFunction: defaultLambda,
};

// Deploy contract and return its typed address
const deployInitialContract = ((): typed_address<parameter_of PokeGame.PokeGame, PokeGame.storage> => {
  const contract1 = Test.originate(contract_of(PokeGame.PokeGame), initial_storage, 0mutez);
  Test.IO.log(
    "Deployed contract 1 to: "
    + Test.String.show(Test.Typed_address.to_address(contract1.taddr))
  );
  return contract1.taddr;
});


export const unitTest = (
  accounts: [address, address],
  contract1_taddr: typed_address<parameter_of PokeGame.PokeGame, PokeGame.storage>
): unit => {

  const [account1, _account2] = accounts;

  // Simulate a transaction
  Test.State.set_source(account1);
  const result1 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("poke", contract1_taddr), unit, 0tez);
  match(result1) {
    when(Fail(_err)): failwith("Transaction failed");
    when(Success(_s)): Test.IO.log("Transaction succeeded");
  };

  // Verify that the poke was stored in storage
  const storage1: PokeGame.storage = Test.get_storage(contract1_taddr);
  Test.IO.log(storage1);
  match(Map.find_opt(account1, storage1.messages)) {
    when(Some(message)): Assert.assert(message == "");
    when (None()): Assert.assert(false);
  };

  // Try poking with a message
  const result2 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("pokeWithMessage", contract1_taddr), "Test message", 0tez);
  match(result2) {
    when(Fail(_err)): failwith("Transaction failed");
    when(Success(_s)): Test.IO.log("Transaction succeeded");
  };

  // Verify that the poke was stored in storage
  const storage2: PokeGame.storage = Test.get_storage(contract1_taddr);
  Test.IO.log(storage2);
  match(Map.find_opt(account1, storage2.messages)) {
    when(Some(message)): Assert.assert(message == "Test message");
    when (None()): Assert.assert(false);
  };

  // Deploy another contract
  const contract2Feedback = "You poked me!";
  const contract2 = Test.originate(contract_of(PokeGame.PokeGame), { ...initial_storage, feedback: contract2Feedback }, 0mutez);
  const contract2Address = Test.Typed_address.to_address(contract2.taddr);
  Test.IO.log(
    "Deployed contract 2 to: "
    + Test.String.show(contract2Address)
  );

  // Poke contract 2 via contract 1
  // Fails without a ticket
  Test.State.set_source(account1);
  const result3 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("pokeAndGetFeedback", contract1_taddr), contract2Address, 0tez);
  match(result3) {
    when(Fail(_err)): Test.IO.log("Correctly failed to poke another contract without a ticket");
    when(Success(_s)): failwith("Was incorrectly able to poke without a ticket");
  };

  // Create a ticket for account 1
  const result4 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("createTicket", contract1_taddr), account1, 0tez);

  // Poke contract 2 via contract 1
  // Succeeds now that account 1 has a ticket
  const result5 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("pokeAndGetFeedback", contract1_taddr), contract2Address, 0tez);
  match(result5) {
    when(Fail(_err)): failwith("Failed to poke with a ticket");
    when(Success(_s)): Test.IO.log("Correctly poked with a ticket");
  };

  // Check that contract 2 called pokeMe in response
  const storage3: PokeGame.storage = Test.get_storage(contract1_taddr);
  match(Map.find_opt(contract2Address, storage3.messages)) {
    when(Some(message)): Assert.assert(message == contract2Feedback);
    when (None()): Assert.assert(false);
  };

  // Test changing the lambda
  const result6 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("updateFeedbackFunction", contract1_taddr), updatedLambda, 0tez);
  match(result6) {
    when(Fail(_err)): failwith("Failed to Update feedback function");
    when(Success(_s)): Test.IO.log("Successfully updated feedback function");
  };

  // Verify that changing the lambda changed the feedback response
  const result7 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("createTicket", contract1_taddr), account1, 0tez);
  const result8 = Test.Contract.transfer(Test.Typed_address.get_entrypoint("pokeAndGetFeedback", contract1_taddr), contract2Address, 0tez);
  match(result8) {
    when(Fail(_err)): failwith("Failed to poke with updated feedback function");
    when(Success(_s)): Test.IO.log("Successfully poked with updated feedback function");
  };
  // Verify the result in storage
  const storage4: PokeGame.storage = Test.get_storage(contract1_taddr);
  match(Map.find_opt(contract2Address, storage4.messages)) {
    when(Some(message)): Assert.assert(message == contract2Feedback + " updated");
    when (None()): failwith("Feedback doesn't match updated feedback function");
  };

};

const testContract = ((): unit => unitTest(accounts, deployInitialContract()))();
